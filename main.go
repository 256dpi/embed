package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

const tmpl = `
// Code generated by github.com/256dpi/embed. DO NOT EDIT.

package {{.Package}}

{{if .Consts}}
{{- range .Files}}
// {{.Comment}}
const {{.Name}} = {{if $.Strings}}{{.String}}{{else}}[]byte{ {{range .Bytes}}{{.}},{{end}} }{{end}}
{{- end}}
{{else}}
// {{.Name}} holds a collection of static files.
var {{.Name}} = map[string]{{if .Strings}}string{{else}}[]byte{{end}}{
{{- range .Files}}
	"{{.Name}}": {{if $.Strings}}{{.String}}{{else}}{ {{range .Bytes}}{{.}},{{end}} }{{end}},
{{- end}}
}
{{end}}
`

type file struct {
	Name    string
	Comment string
	Bytes   []byte
	String  string
}

type data struct {
	Package string
	Export  bool
	Strings bool
	Consts  bool
	Name    string
	Files   []file
}

var output = flag.String("out", "files.go", "output filename")
var pkgName = flag.String("pkg", "main", "package name")
var exportVariables = flag.Bool("export", false, "export variables")
var useStrings = flag.Bool("strings", false, "use strings instead of byte slices")
var stripName = flag.Bool("strip", false, "strip path and extension")
var useConsts = flag.Bool("consts", false, "use constants instead of map")
var mapName = flag.String("name", "files", "the map name")

func main() {
	// parse flags
	flag.Parse()

	// get paths
	paths := flag.Args()
	if len(paths) == 0 {
		flag.Usage()
		return
	}

	// clean paths
	for _, pth := range paths {
		pth = strings.TrimSuffix(pth, "/")
	}

	// prepare map
	var files []file

	// walk all paths
	for _, basePath := range paths {
		err := filepath.Walk(basePath, func(pth string, info os.FileInfo, err error) error {
			// check error
			if err != nil {
				panic(err)
			}

			// ignore directories
			if info.IsDir() {
				return nil
			}

			// read file
			contents, err := ioutil.ReadFile(pth)
			if err != nil {
				panic(err)
			}

			// prepare name
			name := filepath.ToSlash(pth)

			// remove base path
			name = strings.TrimPrefix(name, basePath+"/")

			// strip if requested
			if *stripName || *useConsts {
				name = filepath.Base(name)
				name = strings.TrimSuffix(name, path.Ext(name))
			}

			// make uppercase if exported
			if *useConsts {
				name = titleize(name)
			}

			// store file
			files = append(files, file{
				Name:    name,
				Comment: fmt.Sprintf("%s holds the contents of %s.", name, pth),
				Bytes:   contents,
				String:  strconv.QuoteToASCII(string(contents)),
			})

			return nil
		})
		if err != nil {
			panic(err)
		}
	}

	// prepare template
	tpl, err := template.New("").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	// prepare input
	input := data{
		Package: *pkgName,
		Export:  *exportVariables,
		Strings: *useStrings,
		Consts:  *useConsts,
		Files:   files,
		Name:    *mapName,
	}

	// execute template
	buf := bytes.Buffer{}
	err = tpl.Execute(&buf, input)
	if err != nil {
		panic(err)
	}

	// format output
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	// create file
	f, err := os.Create(*output)
	if err != nil {
		panic(err)
	}

	// write output
	_, err = f.Write(formatted)
	if err != nil {
		panic(err)
	}

	// close file
	err = f.Close()
	if err != nil {
		panic(err)
	}
}

func titleize(input string) string {
	// prepare flag
	upNext := *exportVariables

	// prepare string
	var titleized string

	// process all runes
	for _, v := range input {
		// check if next is up or is already up
		if upNext {
			titleized += strings.ToUpper(string(v))
			upNext = false
			continue
		}

		// check if next should be up
		if v == '-' || v == '_' || v == ' ' {
			upNext = true
			continue
		}

		// add rune
		titleized += string(v)
	}

	return titleized
}
